# 상품 검색 성능 최적화 분석 보고서

## 1. 개요
본 문서는 k6 부하 테스트를 통해 **DB 조인 기반 검색(V1)**과 **역정규화 테이블 기반 검색(V2)**의 성능을 비교 분석한 결과를 기술함.
특히, DB 캐시 효과를 배제하고 실제 운영 환경과 유사한 조건을 만들기 위해 **랜덤 키워드 검색** 시나리오를 적용함.

-   **V1 (조인 기반)**: `Product` 테이블과 10여 개의 카테고리 테이블을 **다중 조인(Multi-Join)**하여 검색.
-   **V2 (역정규화 기반)**: 모든 검색 필드를 단일 테이블로 통합한 **검색 전용 테이블**(`product_searches`)을 조회.

## 2. 테스트 환경
-   **테스트 시나리오**: 10종의 다양한 키워드(Trousers, Shirt, Dress 등)를 무작위로 선택하여 검색 수행.
-   **부하 설정**: 가상 사용자(VUs) 100명, 실행 시간 각 20초.

---

## 3. 📊 최종 성능 비교 (V1 vs V2)

| 측정 항목 | V1 (조인 기반) | V2 (역정규화 기반) | 성능 향상 (V2 vs V1) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 101.05ms | **12.64ms** | 🚀 **8.0배 빠름** |
| **중앙값 (Median)** | 92.00ms | **7.00ms** | 🔥 **13.1배 빠름** |
| **상위 95% 지연 (p95)** | 212.90ms | **41.00ms** | ⚡ **5.2배 더 안정적** |
| **최대 지연 (Max)** | 385.00ms | **253.00ms** | **지연 스파이크 34% 감소** |

---

## 4. 💡 심층 분석
1.  **조인(Join)의 물리적 한계**:
    -   V1은 랜덤 키워드 테스트에서 평균 응답 시간이 **101ms**로, 고정 키워드 테스트(약 58ms) 대비 **약 1.7배 악화**됨. 이는 다양한 검색어 유입 시 DB가 매번 무거운 조인 연산을 수행해야 함을 의미함.
2.  **역정규화의 견고함**:
    -   V2는 키워드 변화에 거의 영향을 받지 않고 **12ms대의 일관된 성능**을 유지함. 단일 테이블 인덱스 스캔의 효율성이 랜덤 쿼리 환경에서 더욱 효과적임을 증명함.
3.  **사용자 경험(UX) 격차**:
    -   실제 사용자가 가장 많이 체감하는 지표인 중앙값(Median)에서 **13배**의 속도 차이가 발생. 이는 검색 결과 로딩 속도에서 결정적인 차이를 만들어냄.

## 5. 기술적 결정 (Technical Decision)

### 5.1. 왜 역정규화(Denormalization)를 선택했는가?
"데이터 중복은 악이다"라는 정규화 원칙은 쓰기(Write) 중심 시스템에서는 유효하지만, **읽기(Read)가 90% 이상인 이커머스 검색**에서는 성능의 제약이 됨.
-   **Join 비용 제거**: 사용자가 검색할 때마다 10개 이상의 테이블을 조인하는 것은 DB의 CPU 자원을 낭비하는 행위임.
-   **인덱싱 최적화**: 단일 테이블(`product_searches`)에 모든 필드를 모아두면, 다양한 필터 조합에 대응하는 `Composite Index`를 생성하기 용이함.
-   **CQRS 패턴 적용**: 쓰기(Command) 모델과 읽기(Query) 모델을 분리하여 각 목적에 맞게 데이터 구조를 최적화함. `ProductSearch` 테이블이 바로 읽기 전용 모델에 해당함.

## 6. 트레이드-오프 (Trade-offs)

### 6.1. 데이터 중복과 스토리지 비용
-   **고민**: 역정규화로 인해 동일한 데이터가 `Product`와 `ProductSearch` 두 곳에 저장되어 스토리지 사용량이 증가함.
-   **결정**: 스토리지 비용(Disk)은 저렴하고, 컴퓨팅 비용(CPU/Time)은 비쌈. 사용자에게 0.1초 더 빠른 검색 결과를 제공하기 위해 디스크를 더 쓰는 것은 합리적인 선택이라고 판단함.

### 6.2. 데이터 정합성 유지 (Synchronization)
-   **고민**: 원본 상품 정보가 수정되었을 때, 검색용 테이블에 즉시 반영되지 않으면 데이터 불일치가 발생할 수 있음.
-   **해결**: 현재는 트랜잭션 내에서 동기적으로 갱신하고 있으나, 향후 MSA 환경에서는 **CDC(Change Data Capture)나 이벤트 기반 아키텍처(Kafka/RabbitMQ)**를 통해 비동기적으로 동기화하는 것이 확장성 측면에서 더 유리할 것임.

## 7. 회고 (Retrospective)
-   **"검색 성능의 9할은 데이터 구조에서 온다."** 아무리 쿼리를 튜닝하고 캐시를 적용해도, 근본적인 테이블 구조가 복잡하면 성능 향상에 명확한 한계가 있음을 깨달음.
-   V1(101ms)에서 V2(12ms)로의 드라마틱한 변화는 단순한 튜닝이 아니라 **아키텍처의 패러다임 전환(Read Model 분리)**이 가져온 결과임을 확인함.
