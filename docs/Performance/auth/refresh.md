# 인증 API 성능 분석 보고서 (V1 vs V2)

## 1. 개요
본 문서는 k6 부하 테스트를 통해 **DB 기반(V1)**과 **Redis 기반(V2)**의 인증 아키텍처 성능을 비교 분석한 결과를 기술함.
테스트는 **Refresh Token의 저장 및 조회 방식**에 따른 성능 차이에 초점을 맞춤.

-   **V1**: RDB(H2)를 사용하여 Refresh Token을 관리.
-   **V2**: In-Memory 저장소인 Redis를 사용하여 Refresh Token을 관리.

## 2. 테스트 시나리오
-   **테스트 스크립트**: `k6/tests/refresh.js`
-   **시나리오**: 로그인 직후, 발급받은 Refresh Token을 사용하여 Access Token을 반복적으로 재발급 요청.
-   **부하 설정**: 가상 사용자(VUs) 200명, 10초간 지속.

---

## 3. 📊 최종 성능 비교 (DB vs Redis)

| 측정 항목 | V1 (DB 기반) | V2 (Redis 기반) | 성능 향상 (V2 vs V1) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 29.55ms | **9.07ms** | 🚀 **3.2배 빠름** |
| **중앙값 (Median)** | 18.00ms | **6.00ms** | 🔥 **3배 빠름** |
| **상위 95% 지연 (p95)** | 100.00ms | **25.00ms** | ⚡ **4배 더 안정적** |
| **최대 지연 (Max)** | 196.00ms | **96.00ms** | **지연 스파이크 51% 감소** |
| **에러율 (Errors)** | **0.64%** | **0.00%** | **안정성 확보** |

---

## 4. 💡 심층 분석

### 4.1. V1(DB)의 실패 원인: Race Condition
테스트 중 V1에서만 간헐적으로 `401 Unauthorized` 에러가 발생함.
-   **원인**: 고부하 상황에서 로그인 직후 Refresh Token이 **DB에 커밋(Insert)되기 전에** k6가 해당 토큰으로 갱신(Select)을 요청함.
-   **현상**: DB에 아직 토큰이 없으므로 "Token Not Found"로 처리되어 인증에 실패함.
-   **시사점**: RDB를 세션 저장소로 사용할 경우, **물리적 Disk I/O 한계로 인해 트랜잭션 지연 및 데이터 불일치**가 발생할 수 있음을 증명함.

### 4.2. V2(Redis)의 압도적 성능
-   **In-Memory 특성**: V2는 모든 작업을 메모리 상에서 처리하므로, Disk I/O가 발생하는 V1에 비해 압도적으로 빠른 응답 속도를 보임.
-   **안정성**: Redis는 단일 스레드 기반으로 Atomic 연산을 보장하므로, 높은 동시성 환경에서도 데이터 정합성 문제나 Race Condition이 발생하지 않았음.
-   **p95 지표**: 상위 5% 요청의 지연 시간이 4배나 감소한 것은, V2가 트래픽 스파이크 상황에서도 사용자 경험을 일관되게 유지할 수 있음을 의미함.

## 5. 기술적 결정 (Technical Decision)

### 5.1. 왜 Redis를 선택했는가?
초기에는 RDB를 이용해 Refresh Token을 관리했으나, 다음과 같은 문제에 직면함.
1.  **I/O 병목**: 매 요청마다 Disk I/O가 발생하여 DB 리소스를 과도하게 점유.
2.  **TTL 관리의 어려움**: 만료된 토큰을 삭제하기 위해 별도의 스케줄러(Batch) 구현이 필요.
3.  **Stateful의 한계**: DB 락(Lock)으로 인해 순간적인 트래픽 스파이크 시 응답 지연 발생 가능성.

이를 해결하기 위해 **In-Memory Key-Value 저장소인 Redis**를 도입하여 고성능, TTL 기반 자동 삭제, Atomic 연산의 이점을 확보함.

### 5.2. 트레이드-오프: 영속성(Persistence)
-   **고민**: Redis는 휘발성 메모리이므로 서버 장애 시 모든 Refresh Token이 유실될 수 있음.
-   **결정**: Refresh Token은 영구 보관 데이터가 아니며, 유실되더라도 사용자가 다시 로그인하면 해결되는 문제임. 따라서 **데이터의 영속성(Durability)을 일부 희생하는 대신, 압도적인 속도(Speed)와 안정성을 선택**하는 것이 합리적이라고 판단함.

## 6. 회고 (Retrospective)
-   "DB는 생각보다 느리고, 캐시는 생각보다 훨씬 빠르다"는 것을 정량적 데이터로 확인.
-   특히 V1의 **0.64% 에러율**은, 이론으로만 알던 동시성 문제가 실제 서비스 장애로 이어질 수 있음을 보여준 값진 경험임.
-   **"수명이 짧고 변동성이 큰 데이터(세션, 토큰 등)는 반드시 In-Memory 저장소로 분리한다"** 는 아키텍처 설계 원칙을 확립하게 됨.
