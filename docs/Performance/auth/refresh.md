# 성능 향상 분석 보고서

## 개요
본 문서는 k6 부하 테스트를 통해 **DB 기반 인증(v1)**과 **Redis 기반 인증(v2)**을 비교하여 성능 향상 효과를 분석한 결과를 담고 있다.
테스트는 두 가지 관점에서 진행되었다:
1. **전체 사용자 흐름(User Journey)**: 회원가입부터 탈퇴까지의 일반적인 시나리오
2. **Refresh Token 성능 심층 분석**: 서버 부하의 핵심인 토큰 갱신 로직 집중 테스트

---

## 1. 전체 사용자 흐름 (User Journey) 테스트
* **테스트 스크립트**: `auth-test.js` (회원가입 → 로그인 → 토큰 갱신 → 로그아웃 → 탈퇴)
* **VUs**: 200, **Duration**: 10초

### 결과 요약

| 항목 | DB 인증 (v1) | Redis 인증 (v2) |
|------|--------------|-----------------|
| 총 요청 수 (http_reqs) | 2400 (150.67/s) | 2400 (94.41/s) |
| 성공률 (checks_succeeded) | 100% (2400/2400) | 100% (2400/2400) |
| 평균 응답 시간 (avg) | 366.27ms | **341.3ms** |
| 중앙값 응답 시간 (med) | 251.08ms | **215.76ms** |
| 95% 응답 시간 (p95) | 1.01s | **993ms** |
| Iteration 평균 시간 | 7.2s | **7.05s** |

### 분석
* Redis 환경이 전체적인 응답 속도에서 약 **7~10% 성능 우위**를 보임.
* 일반적인 API 호출(Access Token 검증)은 메모리(JWT Signature)에서 처리되므로 차이가 크지 않음.

---

## 2. Refresh Token 성능 심층 분석 (핵심 병목 구간)
* **테스트 목적**: 실제 DB I/O가 발생하는 **토큰 갱신(Refresh)** 단계의 병목 현상 규명
* **테스트 스크립트**: `refresh.js` (로그인 직후 고속 Refresh 요청)
* **VUs**: 200, **Duration**: 10초

### 📊 상세 비교 결과

| 측정 항목 | DB 기반 (V1) | Redis 기반 (V2) | 성능 향상 (V2 vs V1) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 29.55ms | **9.07ms** | 🚀 **3.2배 빠름** |
| **중앙값 (Median)** | 18ms | **6ms** | **3배 빠름** |
| **상위 95% 지연 (p95)** | 100ms | **25ms** | ⚡ **4배 더 안정적** |
| **최대 지연 (Max)** | 196ms | **96ms** | **스파이크 방어 우수** |
| **에러율 (Error Rate)** | **0.64% (실패 발생)** | **0.00% (완벽 성공)** | **데이터 정합성 보장** |

### 🚨 V1(DB) 실패 원인 분석 (Race Condition)
테스트 도중 V1에서만 간헐적으로 `401 Unauthorized` 에러가 발생함.
* **원인**: 고부하 상황에서 **DB 트랜잭션 커밋(Insert)이 지연**되는 동안, k6가 즉시 Refresh 요청(Select)을 보냄.
* **현상**: DB에 아직 토큰 데이터가 저장되지 않은 상태에서 조회가 일어나 **"Token Not Found"** 처리됨.
* **의미**: RDB를 세션 저장소로 사용할 경우, **물리적 Disk I/O 한계로 인해 트랜잭션 지연 및 데이터 불일치**가 발생할 수 있음을 증명.

### ✅ 결론
Redis 기반 인증(V2)은 단순 속도 향상뿐만 아니라, **고부하 트래픽에서의 데이터 정합성과 트랜잭션 안정성**을 완벽하게 보장한다.
특히 **p95(상위 5% 지연)가 4배나 감소**했다는 점은 사용자 경험(UX) 측면에서 매우 중요한 개선점이다.

---

## 기술적 선택과 이유 (Technical Decision)

### 왜 Redis인가?
초기에는 RDB(H2/MySQL)를 이용해 Refresh Token을 관리했으나, 다음과 같은 문제점에 직면했습니다.
1. **I/O 병목**: 매 요청(로그인, 갱신, 로그아웃)마다 Disk I/O가 발생하여 DB 리소스를 점유함.
2. **TTL 관리의 어려움**: 만료된 토큰을 삭제하기 위해 별도의 스케줄러(Batch)를 돌려야 함.
3. **Stateful의 한계**: DB 락(Lock) 이슈 등으로 인해 순간적인 트래픽 스파이크 시 응답 지연 발생.

이를 해결하기 위해 **In-Memory Key-Value Store인 Redis**를 도입했습니다.
- **고성능**: 메모리 기반으로 1ms 이하의 접근 속도 보장.
- **TTL 지원**: 데이터 만료 시 자동 삭제되므로 별도의 배치 작업 불필요.
- **Atomic Operation**: 싱글 스레드 기반으로 Race Condition 없이 토큰 상태(유효/무효) 관리 가능.

## 트레이드 오프와 고민의 흔적 (Trade-off & Constraints)

### 1. 보안 vs 편의성 (RTR 기법)
- **고민**: Refresh Token이 탈취되면 영원히 접근 가능한 것 아닌가?
- **해결**: **RTR(Refresh Token Rotation)** 방식을 도입했습니다. 토큰을 한 번 사용하면 즉시 폐기하고(Blacklist), 새로운 토큰을 발급합니다. V2에서는 Redis에 이전 토큰을 'Logout' 상태로 저장하여 재사용 시도를 원천 차단했습니다.

### 2. 영속성(Persistence) 문제
- **트레이드 오프**: Redis는 휘발성 메모리이므로 서버 재시작 시 데이터가 날아갈 수 있습니다.
- **판단**: Refresh Token은 '영구 보관' 데이터가 아닙니다. 날아가면 사용자가 다시 로그인하면 그만인 데이터입니다. 따라서 **속도(Speed)를 위해 영속성(Durability)을 희생**하는 것이 합리적이라고 판단했습니다.

## 회고와 배운 점 (Retrospective)

이번 성능 테스트를 통해 **"DB는 생각보다 느리고, 캐시는 생각보다 훨씬 빠르다"**는 것을 뼈저리게 느꼈습니다.
특히 단순한 응답 속도 차이(30ms vs 9ms)보다 충격적이었던 것은 **V1에서의 0.64% 에러율(Race Condition)**이었습니다.
"트랜잭션이 커밋되기 전에 읽기 요청이 올 수 있다"는 이론적인 동시성 문제가, 실제 부하 테스트 환경에서 어떻게 서비스 장애(로그인 실패)로 이어지는지 눈으로 확인한 값진 경험이었습니다.
앞으로 **"변동성이 크고 수명이 짧은 데이터(Session, Token)"는 반드시 인메모리 저장소로 분리**해야 한다는 아키텍처 원칙을 확립하게 되었습니다.