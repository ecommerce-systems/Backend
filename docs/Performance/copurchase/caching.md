# 공동 구매 추천 시스템 캐싱 성능 분석 보고서

## 개요
본 문서는 사용자 주문 데이터를 분석하여 연관 상품을 추천하는 **'공동 구매(Co-Purchase) 추천 API'**의 성능을 분석한 결과이다.
해당 API는 실시간 주문 데이터 집계가 필요하여 연산 비용이 높으므로, **Redis 캐싱 전략**을 도입하여 성능을 최적화하였다.

## 테스트 환경
- **테스트 시나리오**:
    1. 관리자가 상품 2개(A, B) 생성
    2. 사용자가 상품 A와 B를 포함한 주문 생성 (데이터 적재)
    3. **1차 조회 (Cold Read)**: 상품 A에 대한 추천 상품 조회 (DB 연산 발생)
    4. **2차 조회 (Hot Read)**: 동일한 상품 A에 대해 다시 조회 (Redis 캐시 적중 예상)
- **부하 설정**: VUs 5, Duration 30초 (데이터 생성 및 계산 로직 검증 위주)

---

## 📊 캐시 적중(Hit) 여부에 따른 성능 비교

| 측정 항목 | 1차 조회 (Cache Miss) | 2차 조회 (Cache Hit) | 성능 향상 (Hit vs Miss) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 289.34ms | **13.36ms** | 🚀 **21.6배 빠름** |
| **중앙값 (Median)** | 255.50ms | **10.00ms** | 🔥 **25.5배 빠름** |
| **최소 응답 (Min)** | 128.00ms | **3.00ms** | **42배 빠름** |
| **최대 지연 (Max)** | 748.00ms | **57.00ms** | **지연 스파이크 제거** |
| **처리 로직** | DB 집계 쿼리 실행 | Redis Key-Value 조회 | - |

### 💡 심층 분석
1. **DB 집계 연산의 비용**:
   - 1차 조회 시 `Order` 및 `OrderDetail` 테이블을 스캔하여 '상품 A와 함께 구매된 상품'을 카운팅하고 정렬하는 과정에서 평균 **약 0.3초**가 소요됨.
   - 데이터 양이 늘어날수록 이 시간은 선형적 또는 지수적으로 증가할 위험이 있음.
2. **Redis 캐싱의 효율성**:
   - 2차 조회부터는 연산 없이 메모리에서 결과를 즉시 반환하여 **10ms 내외**의 초고속 응답을 보장함.
   - 이는 사용자 경험(UX) 측면에서 '로딩 없는 즉각적인 추천'을 가능하게 함.
3. **리소스 절약**:
   - 반복적인 조회 요청을 캐시가 처리함으로써 DB의 CPU 및 I/O 부하를 획기적으로 줄여줌.

---

## 기술적 선택과 이유 (Technical Decision)

### 왜 Redis 캐싱인가? (Compute vs Store)
추천 시스템 로직은 `O(N)` 이상의 복잡도를 가지는 집계 연산입니다. 매 요청마다 DB에서 `GROUP BY`와 `COUNT`를 수행하는 것은 비효율적입니다.
**"한 번 계산된 결과는 변하지 않는다(당분간)"**는 특성을 이용하여, **컴퓨팅 비용(CPU)을 스토리지 비용(Memory)으로 치환**하는 전략을 선택했습니다.

## 트레이드 오프와 고민의 흔적 (Trade-off & Constraints)

### 1. 데이터 정합성 (Consistency)
- **고민**: "방금 누군가 주문했는데, 추천 목록에 바로 안 뜨면 어떡하지?"
- **트레이드 오프**: 추천 기능은 재고(Stock)처럼 100% 실시간 정합성이 중요하지 않습니다. 1분 전의 추천 데이터나 지금의 데이터나 유저 경험에는 큰 차이가 없습니다.
- **결정**: **최종적 일관성(Eventual Consistency)** 모델을 채택하여, 캐시 TTL(1시간) 동안은 갱신되지 않도록 하여 DB 부하를 최소화했습니다.

### 2. Cache Stampede (조회 폭주)
- **고민**: 인기 상품의 캐시가 만료되는 순간, 수천 명의 요청이 동시에 DB로 뚫고 들어오면(Thundering Herd)?
- **대안**: 향후에는 `Mutex Lock`을 사용하여 한 명만 DB를 갱신하게 하거나, 만료 시간이 다른 `Jitter`를 적용하는 방안을 고려하고 있습니다.

## 회고와 배운 점 (Retrospective)

**"가장 빠른 쿼리는 쿼리를 안 하는 것이다."**
이번 테스트 결과(289ms → 13ms, 21배 향상)는 이 명언을 완벽하게 증명했습니다.
단순히 데이터를 저장하는 것을 넘어, **"비싼 연산의 결과를 저장"**하는 것이 시스템 전체의 효율성을 얼마나 높여주는지 체감했습니다.
또한, k6의 `group` 기능을 사용하여 Cold/Hot Read를 분리 측정함으로써 캐싱의 효과를 정량적으로 입증하는 테스트 방법론도 익힐 수 있었습니다.