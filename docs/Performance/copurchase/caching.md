# 공동 구매 추천 시스템 캐싱 성능 분석 보고서

## 개요
본 문서는 사용자 주문 데이터를 분석하여 연관 상품을 추천하는 **'공동 구매(Co-Purchase) 추천 API'**의 성능을 분석한 결과이다.
해당 API는 실시간 주문 데이터 집계가 필요하여 연산 비용이 높으므로, **Redis 캐싱 전략**을 도입하여 성능을 최적화하였다.

## 테스트 환경
- **테스트 시나리오**:
    1. 관리자가 상품 2개(A, B) 생성
    2. 사용자가 상품 A와 B를 포함한 주문 생성 (데이터 적재)
    3. **1차 조회 (Cold Read)**: 상품 A에 대한 추천 상품 조회 (DB 연산 발생)
    4. **2차 조회 (Hot Read)**: 동일한 상품 A에 대해 다시 조회 (Redis 캐시 적중 예상)
- **부하 설정**: VUs 5, Duration 30초 (데이터 생성 및 계산 로직 검증 위주)

---

## 📊 캐시 적중(Hit) 여부에 따른 성능 비교

| 측정 항목 | 1차 조회 (Cache Miss) | 2차 조회 (Cache Hit) | 성능 향상 (Hit vs Miss) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 289.34ms | **13.36ms** | 🚀 **21.6배 빠름** |
| **중앙값 (Median)** | 255.50ms | **10.00ms** | 🔥 **25.5배 빠름** |
| **최소 응답 (Min)** | 128.00ms | **3.00ms** | **42배 빠름** |
| **최대 지연 (Max)** | 748.00ms | **57.00ms** | **지연 스파이크 제거** |
| **처리 로직** | DB 집계 쿼리 실행 | Redis Key-Value 조회 | - |

### 💡 심층 분석
1. **DB 집계 연산의 비용**:
   - 1차 조회 시 `Order` 및 `OrderDetail` 테이블을 스캔하여 '상품 A와 함께 구매된 상품'을 카운팅하고 정렬하는 과정에서 평균 **약 0.3초**가 소요됨.
   - 데이터 양이 늘어날수록 이 시간은 선형적 또는 지수적으로 증가할 위험이 있음.
2. **Redis 캐싱의 효율성**:
   - 2차 조회부터는 연산 없이 메모리에서 결과를 즉시 반환하여 **10ms 내외**의 초고속 응답을 보장함.
   - 이는 사용자 경험(UX) 측면에서 '로딩 없는 즉각적인 추천'을 가능하게 함.
3. **리소스 절약**:
   - 반복적인 조회 요청을 캐시가 처리함으로써 DB의 CPU 및 I/O 부하를 획기적으로 줄여줌.

---

## 캐싱 전략 및 아키텍처

- **전략**: Look-Aside Cache (Lazy Loading)
    - 요청 시 Redis 확인 → 없으면 DB 조회 및 계산 → Redis에 저장(TTL 적용) → 반환
- **Key 설계**: `recommendation::{productId}`
- **TTL (만료 시간)**: 추천 데이터의 실시간성과 성능 간의 균형을 위해 적절한 시간 설정 (예: 1시간)

## 결론
추천 시스템과 같이 **'읽기 빈도(Read Frequency)는 높지만, 데이터 갱신(Update) 주기는 상대적으로 긴'** 기능에서 Redis 캐싱은 필수적이다.
이번 테스트를 통해 캐싱 도입 시 **약 20배 이상의 성능 향상** 효과가 있음을 정량적으로 입증하였다.

## 향후 과제
- **Cache Warm-up**: 배치(Batch) 작업을 통해 인기 상품의 추천 데이터를 미리 계산하여 캐시에 적재하는 전략 고려.
- **정합성 관리**: 주문 발생 시 실시간으로 캐시를 갱신할지, 만료될 때까지 기다릴지에 대한 정책 고도화 필요.
