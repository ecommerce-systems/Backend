# 공동 구매 추천 API 성능 분석 (V1 vs V2, 캐싱 포함)

## 개요
본 문서는 **공동 구매(Co-Purchase) 추천 API**의 V1과 V2 버전에 대해, **캐시(Cache) 적용 여부**까지 고려한 심층 성능 분석 결과를 담고 있습니다.

총 4가지 시나리오를 비교하여 API 디자인 패턴과 캐싱 전략의 복합적인 효과를 측정했습니다.

-   **V1 (N+1 요청 방식):** 클라이언트가 추천 상품 ID 목록을 먼저 받은 후(`1`회 요청), 각 ID에 해당하는 상품의 상세 정보를 다시 개별적으로 요청하는 방식(`N`회 요청).
-   **V2 (단일 요청 최적화 방식):** 한 번의 요청으로 추천 상품들의 모든 상세 정보를 받는 최적화된 방식.

## 테스트 시나리오
-   **테스트 스크립트**: `k6/tests/copurchase.js`
-   **시나리오**: V1과 V2 각 그룹에 대해, 가상 사용자(VU) 5명이 45초 동안 아래의 흐름을 반복합니다.
    1.  테스트에 필요한 상품과 주문 데이터를 생성합니다.
    2.  **최초 조회 (Cache Miss):** API를 처음 호출하여 캐시가 없는 상태의 성능을 측정합니다.
    3.  **반복 조회 (Cache Hit):** 동일한 API를 즉시 다시 호출하여 캐시가 적용된 상태의 성능을 측정합니다.

---

## 📊 최종 성능 비교 결과 (4가지 시나리오)

| 측정 항목 | V1 - Miss (N+1) | V1 - Hit (N+1) | V2 - Miss (단일) | **V2 - Hit (단일)** |
| :--- | :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 251.22ms | 8.41ms | 210.00ms | **5.93ms** |
| **중앙값 (Median)** | 244.00ms | 6.00ms | 213.00ms | **5.00ms** |
| **상위 95% 지연 (p95)** | 346.00ms | 15.20ms | 246.30ms | **10.00ms** |
| **최대 지연 (Max)** | 487.00ms | 47.00ms | 262.00ms | **12.00ms** |

---

### 💡 심층 분석

#### 1. 캐싱의 압도적인 효과
-   **V1:** 캐시가 적용되자 평균 응답 속도가 **251ms에서 8ms로 약 30배 향상**되었습니다.
-   **V2:** 캐시가 적용되자 평균 응답 속도가 **210ms에서 6ms로 약 35배 향상**되었습니다.
-   **결론:** 연관 상품 추천과 같이 연산 비용이 비싸고 데이터가 자주 변하지 않는 경우, 캐싱은 선택이 아닌 필수적인 최적화 전략임을 명확히 보여줍니다.

#### 2. 캐시 미스(Cache Miss) 상황에서의 V1과 V2 비교
-   캐시가 없는 최초 요청 상황에서는 V2(`210ms`)가 V1(`251ms`)보다 약 **1.2배** 빠릅니다.
-   **분석:** V1은 여러 번의 HTTP 요청으로 인한 **네트워크 왕복 시간(RTT)**이 누적되어 V2보다 느립니다. 반면 V2는 단일 요청으로 통신 횟수를 최소화하여 더 나은 성능을 보입니다.

#### 3. 캐시 히트(Cache Hit) 상황에서의 V1과 V2 비교: 네트워크 비용의 중요성
-   캐시가 적용된 후에도 V2(`6ms`)는 V1(`8ms`)보다 **약 1.4배** 더 빠릅니다.
-   **분석:** 이 차이는 순전히 **네트워크 비용** 때문에 발생합니다. V1은 캐시를 통해 추천 ID 목록을 빠르게 가져오더라도, 여전히 **클라이언트는 N번의 추가적인 HTTP 요청**을 보내야 합니다. V2는 캐시에서 가져온 **완성된 데이터를 단 한 번의 HTTP 응답**으로 전달하기 때문에 가장 빠릅니다.

## 최종 결론

1.  **캐싱은 가장 효과적인 성능 개선 도구이다:** 비싼 DB 연산 결과를 캐싱하는 것만으로 30배 이상의 성능 향상을 얻을 수 있었습니다.
2.  **API 디자인이 성능을 결정한다:** 캐시가 적용된 후에도 V1의 N+1 요청 방식은 불필요한 네트워크 통신으로 인해 V2보다 느렸습니다. 이는 백엔드 최적화뿐만 아니라, **클라이언트와 서버 간의 통신을 효율적으로 설계하는 것**이 얼마나 중요한지 보여주는 결과입니다.

결론적으로, **"캐싱 전략과 효율적인 API 디자인(단일 요청)이 결합된 V2 방식"**이 어떤 상황에서든 가장 우수하고 안정적인 성능을 제공하는 최적의 아키텍처임이 증명되었습니다.