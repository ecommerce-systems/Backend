# 공동 구매 추천 API 성능 분석 보고서 (V1 vs V2, 캐싱 포함)

## 1. 개요
본 문서는 **공동 구매(Co-Purchase) 추천 API**의 V1과 V2 버전에 대해, **캐시(Cache) 적용 여부**까지 고려한 심층 성능 분석 결과를 기술함.

총 4가지 시나리오를 비교하여 API 디자인 패턴과 캐싱 전략의 복합적인 효과를 측정하는 것을 목적으로 함.

-   **V1 (N+1 요청 방식):** 클라이언트가 추천 상품 ID 목록을 먼저 받은 후(`1`회 요청), 각 ID에 해당하는 상품의 상세 정보를 다시 개별적으로 요청하는 방식(`N`회 요청).
-   **V2 (단일 요청 최적화 방식):** 한 번의 요청으로 추천 상품들의 모든 상세 정보를 받는 최적화된 방식.

## 2. 테스트 시나리오
-   **테스트 스크립트**: `k6/tests/copurchase.js`
-   **시나리오**: V1과 V2 각 그룹에 대해, 가상 사용자(VU) 5명이 45초 동안 아래의 흐름을 반복함.
    1.  테스트에 필요한 상품과 주문 데이터를 생성.
    2.  **최초 조회 (Cache Miss):** API를 처음 호출하여 캐시가 없는 상태의 성능을 측정.
    3.  **반복 조회 (Cache Hit):** 동일한 API를 즉시 다시 호출하여 캐시가 적용된 상태의 성능을 측정.

---

## 3. 📊 최종 성능 비교 (4가지 시나리오)

| 측정 항목 | V1 - Miss (N+1) | V1 - Hit (N+1) | V2 - Miss (단일) | **V2 - Hit (단일)** |
| :--- | :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 251.22ms | 8.41ms | 210.00ms | **5.93ms** |
| **중앙값 (Median)** | 244.00ms | 6.00ms | 213.00ms | 🔥 **5.00ms** |
| **상위 95% 지연 (p95)** | 346.00ms | 15.20ms | 246.30ms | ⚡️ **10.00ms** |
| **최대 지연 (Max)** | 487.00ms | 47.00ms | 262.00ms | **12.00ms** |

---

## 4. 💡 심층 분석

#### 4.1. 캐싱의 압도적인 효과
-   **V1:** 캐시 적용 후 평균 응답 속도가 **251ms에서 8ms로 약 30배 향상**됨.
-   **V2:** 캐시 적용 후 평균 응답 속도가 **210ms에서 6ms로 약 35배 향상**됨.
-   **결론:** 연산 비용이 비싸고 데이터가 자주 변하지 않는 연관 상품 추천의 경우, 캐싱은 선택이 아닌 필수적인 최적화 전략임을 명확히 보여줌.

#### 4.2. 캐시 미스(Cache Miss) 상황에서의 V1과 V2 비교
-   캐시가 없는 최초 요청 시, V2(`210ms`)가 V1(`251ms`)보다 약 **1.2배** 빠름.
-   **분석:** V1은 여러 번의 HTTP 요청으로 인한 **네트워크 왕복 시간(RTT)**이 누적되어 V2보다 느림. 반면 V2는 단일 요청으로 통신 횟수를 최소화하여 더 나은 성능을 보임.

#### 4.3. 캐시 히트(Cache Hit) 상황에서의 V1과 V2 비교: 네트워크 비용의 중요성
-   캐시가 적용된 후에도 V2(`6ms`)는 V1(`8ms`)보다 **약 1.4배** 더 빠름.
-   **분석:** 이 차이는 순전히 **네트워크 비용** 때문에 발생함. V1은 캐시를 통해 추천 ID 목록을 빠르게 가져오더라도, 여전히 **클라이언트는 N번의 추가적인 HTTP 요청**을 보내야 함. V2는 캐시에서 가져온 **완성된 데이터를 단 한 번의 HTTP 응답**으로 전달하기 때문에 가장 빠름.

## 5. 기술적 결정 (Technical Decision)

### 5.1. 왜 단일 요청(Single-Request) API를 지향했는가?
모바일 환경 등 네트워크 지연에 민감한 클라이언트를 고려할 때, **'채팅'처럼 여러 번 통신하는(chatty) API는 사용자 경험(UX)을 저해**하는 주된 요인이 됨.
-   **N+1 문제 해결**: V1 방식은 클라이언트가 N번의 추가 요청을 보내야 하므로, 서버의 성능과 무관하게 전체 프로세스 완료 시간이 길어짐.
-   **Read Model 활용**: V2는 **읽기 전용 모델(Read Model)**인 `ProductSearch` 엔티티를 사용하여, 클라이언트에게 필요한 모든 정보를 한 번에 가공하여 제공함. 이는 CQRS 패턴의 기본 사상과 일치함.

## 6. 트레이드-오프 (Trade-offs)

### 6.1. 데이터 중복과 정합성
-   **고민**: V2가 의존하는 `ProductSearch`는 `Product` 원본 데이터의 복사본이므로, 데이터 중복이 발생함. 원본 상품 가격이 변경될 때 `ProductSearch`의 가격 정보도 함께 갱신해주어야 하는 정합성 이슈가 있음.
-   **결정**: 현재는 상품 서비스 내에서 트랜잭션을 통해 동기적으로 갱신하고 있음. **읽기 성능의 막대한 이점**이 데이터 중복으로 인한 약간의 스토리지 비용 증가와 관리 포인트를 감수할 만큼 크다고 판단함.

## 7. 회고 (Retrospective)
-   백엔드의 DB 쿼리 최적화만큼이나 **클라이언트-서버 간의 통신 프로토콜 설계**가 전체 시스템 성능에 지대한 영향을 미침을 확인함.
-   V1의 'Cache Hit' 상황에서도 V2 'Cache Hit'보다 느린 결과는, **서버 로직뿐만 아니라 네트워크 왕복 횟수 자체가 성능의 주요 병목**이 될 수 있음을 시사함.
-   따라서 효과적인 API 설계란, **"클라이언트가 최소한의 요청으로 원하는 정보를 모두 얻어갈 수 있도록 하는 것"**이라는 원칙을 다시 한번 확립하게 됨.