# 공동 구매 추천 API 성능 분석 (V1 vs V2)

## 개요
본 문서는 **공동 구매(Co-Purchase) 추천 API**의 V1과 V2 버전 성능을 k6 부하 테스트를 통해 비교 분석한 결과를 담고 있습니다.

-   **V1 (N+1 문제 모델):** 클라이언트가 추천 상품 ID 목록을 먼저 받은 후(`1`회 요청), 각 ID에 해당하는 상품의 상세 정보를 다시 개별적으로 요청하는 방식(`N`회 요청). 총 **N+1**회의 네트워크 통신이 발생합니다.
-   **V2 (단일 요청 최적화 모델):** 한 번의 요청으로 추천 상품들의 모든 상세 정보를 받는 최적화된 방식. 백엔드에서는 비정규화된 `product_searches` 테이블을 조회하여 성능을 높였습니다.

## 테스트 시나리오
-   **테스트 스크립트**: `k6/tests/copurchase.js`
-   **시나리오**: V1과 V2 각 시나리오에 대해, 가상 사용자(VUs) 5명이 30초 동안 아래의 흐름을 반복합니다.
    1.  테스트에 필요한 상품 2개와 주문 데이터를 생성합니다.
    2.  V1 또는 V2 엔드포인트를 호출하여 추천 상품 목록을 조회합니다.
    3.  V1의 경우, 응답받은 ID 목록으로 N개의 추가 상세 조회 요청을 보냅니다.
    4.  각 시나리오의 전체 수행 시간을 측정합니다.

---

## 📊 최종 성능 비교 결과 (V1 vs V2)

| 측정 항목 | V1 (N+1 요청) | V2 (단일 요청) | 성능 향상 (V2 vs V1) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 324.91ms | **244.96ms** | 🚀 **1.33배 빠름** |
| **중앙값 (Median)** | 241.50ms | **246.00ms** | - |
| **상위 95% 지연 (p95)** | 1117.75ms | **269.40ms** | ⚡ **4.1배 더 안정적** |
| **최대 지연 (Max)** | 1629.00ms | **302.00ms** | **지연 스파이크 대폭 감소** |
| **테스트 성공률** | 100% | 100% | - |

### 💡 심층 분석
1.  **N+1 요청의 오버헤드:** V1 방식은 여러 번의 HTTP 요청을 보내야 하므로 네트워크 지연(latency)이 누적됩니다. 이로 인해 평균 응답 속도가 V2보다 느리게 측정되었습니다.
2.  **응답 시간 안정성 (p95):** 가장 주목할 만한 차이는 `p95` 지표입니다. V1은 부하 상황에서 일부 요청이 **1.1초**를 초과하는 등 응답 시간의 편차가 매우 컸습니다. 반면 V2는 대부분의 요청이 **270ms** 내에서 안정적으로 처리되었습니다. 이는 V2가 훨씬 더 예측 가능하고 일관된 사용자 경험을 제공함을 의미합니다.
3.  **예상보다 작은 평균 속도 차이의 원인:** V2가 V1보다 약 1.3배 빠른것으로 나타났지만, `product-search` 테스트처럼 10배 이상의 극적인 차이는 보이지 않았습니다. 그 이유는 다음과 같습니다.
    *   **V2의 내부 쿼리:** V2 서비스는 추천 ID를 가져오기 위한 쿼리(`co_purchase` 테이블)와 상세 정보를 가져오기 위한 쿼리(`product_searches` 테이블)로, 내부적으로 두 번의 DB 조회가 일어납니다.
    *   **V1의 개별 조회 성능:** V1의 N+1 요청에서 개별 상품을 조회하는 `/api/v1/products/{id}` API는 기본키(PK)를 기반으로 조회하므로, `JOIN`이 있더라도 데이터베이스가 매우 빠르게 처리합니다.
    *   결론적으로 V2의 성능 이점이 V1의 빠른 개별 조회 속도로 인해 일부 상쇄되어, 평균 속도에서는 큰 차이가 나지 않은 것으로 분석됩니다.

## 결론
**"N+1 요청 방식은 응답 시간의 안정성을 크게 해친다."**

평균 응답 속도에서는 큰 차이가 없었지만, `p95`와 `max` 지표에서 나타나듯이 V1의 N+1 방식은 특정 상황에서 응답 시간이 급격히 느려지는 **롱테일(Long-tail) 문제**에 취약합니다. 반면 V2는 백엔드에서 추가적인 조회가 있더라도 단일 요청으로 응답을 제어하므로, 훨씬 안정적이고 예측 가능한 성능을 제공합니다.

따라서 사용자 경험의 일관성과 시스템 안정성 측면에서 **V2의 단일 요청 방식**이 명백한 우위를 가집니다.
