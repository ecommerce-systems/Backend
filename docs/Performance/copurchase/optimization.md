# Co-Purchase API 성능 최적화 (V1 vs V2)

## 개요
이 문서는 상품 추천(Co-Purchase) API의 성능 최적화 과정을 설명하고, 기존 방식(V1)과 최적화된 방식(V2)의 성능 차이를 비교합니다.

## 변경 사항

### V1: N+1 문제 방식 (기존)
- **동작 방식**: 
  1. 클라이언트가 추천 상품 목록을 요청합니다.
  2. 서버는 `CoPurchase` 테이블을 조회하여 연관된 `targetProduct`의 **ID 목록**만 반환합니다.
  3. 클라이언트는 각 ID에 대해 상세 정보를 얻기 위해 상품 상세 API(`GET /products/{id}`)를 **개별적으로 호출**해야 합니다.
- **문제점**: 
  - 추천 상품이 10개라면, 총 11번의 요청(1 List + 10 Detail)이 발생합니다 (N+1 문제).
  - 네트워크 오버헤드가 크고, DB 커넥션 풀을 많이 점유하게 됩니다.

### V2: 반정규화 및 단일 쿼리 방식 (최적화)
- **동작 방식**:
  1. 클라이언트가 추천 상품 목록을 요청합니다.
  2. 서버는 `CoPurchase` 테이블에서 연관 상품 ID를 조회합니다.
  3. `ProductSearch` (반정규화된 읽기 전용 테이블)에서 `IN` 쿼리를 사용하여 해당 ID들의 상세 정보를 **한 번에 조회**합니다.
  4. 상세 정보가 포함된 리스트를 반환합니다.
- **장점**:
  - 단 1번의 요청으로 모든 데이터 조회가 완료됩니다.
  - `ProductSearch` 테이블은 조인이 필요 없는 플랫한 구조이므로 조회 성능이 뛰어납니다.

## 성능 비교 테스트 (K6)

### 테스트 시나리오
- 가상 사용자(VU): 5명
- 상품 생성 및 주문 생성 후 추천 목록 조회
- **V1**: 추천 API 호출 후 반환된 개수만큼 상세 API 추가 호출
- **V2**: 추천 API(V2) 단일 호출

### 예상 결과
- **응답 시간(Latency)**: V2가 V1(총합)보다 현저히 낮을 것으로 예상됨.
- **처리량(Throughput)**: V2가 동일 시간 내 더 많은 요청을 처리 가능.
- **네트워크 부하**: V2가 요청 횟수가 적어 네트워크 부하 감소.

## 결론
V2 방식은 클라이언트-서버 간의 통신 횟수를 획기적으로 줄이고, 반정규화된 테이블을 활용하여 조인 비용을 제거함으로써 추천 시스템의 성능을 크게 향상시켰습니다.
