# 상품 검색 API 성능 비교 (V1 vs V2)

## 개요
이 문서는 상품 검색 및 목록 조회 API의 성능 비교를 다룹니다. 기존의 정규화된 테이블을 조인하여 조회하는 방식(V1)과 반정규화된 단일 테이블을 조회하는 방식(V2)의 성능 차이를 분석합니다.

## 비교 대상

### V1: 정규화된 테이블 조인 (기존)
- **API**: `GET /api/v1/products/search/results`
- **구조**: `Product` 테이블이 `ProductType`, `ProductGroup`, `ColourGroup` 등 10개 이상의 메타데이터 테이블과 정규화되어 있음.
- **동작**: 상품 목록 조회 시, Hibernate(JPA)가 연관된 엔티티들을 로딩하기 위해 다수의 조인(Join) 또는 추가 쿼리(N+1 문제 발생 가능성)를 실행함.
- **특징**: 데이터 일관성은 높으나, 조회 시 복잡도가 높음.

### V2: 반정규화된 테이블 조회 (최적화)
- **API**: `GET /api/v2/products/search/results`
- **구조**: `ProductSearch`라는 단일 테이블에 모든 필요한 메타데이터(카테고리명, 색상명 등)를 컬럼으로 포함(Flattened).
- **동작**: 단일 테이블에 대한 단순 `SELECT` 쿼리 실행. 조인이 전혀 발생하지 않음.
- **특징**: 읽기 성능이 극대화됨. 쓰기 시 동기화 오버헤드가 있음.

## 성능 비교 테스트 (K6)

### 테스트 환경
- **DB**: H2 (In-Memory) - 실제 운영 환경(Disk I/O 발생)에서는 V2의 이점이 더 클 것으로 예상됨.
- **데이터**: 테스트 스크립트에서 생성된 더미 데이터.
- **부하**: 동시 사용자(VU) 50~200명 수준의 검색 요청.

### 예상 결과
1.  **응답 속도 (Latency)**: V2가 V1보다 빠름. 특히 데이터 양이 많아질수록 조인 비용이 없는 V2의 이점이 커짐.
2.  **CPU 사용량**: V1은 복잡한 조인 연산으로 DB CPU 사용량이 높을 수 있음.
3.  **확장성**: V2 구조는 NoSQL(Elasticsearch 등)로의 마이그레이션이 용이함.

## 결론
V2 방식은 복잡한 E-commerce 상품 구조에서 조회 성능을 확보하기 위한 필수적인 전략입니다. 반정규화를 통해 조인 연산을 제거함으로써, 트래픽이 몰리는 검색/목록 조회 기능의 안정성을 높였습니다.
