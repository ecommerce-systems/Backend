# 검색 성능 최적화 분석 보고서

## 개요
본 문서는 k6 부하 테스트를 통해 **기존 정규화된 DB 구조 기반 검색(v1)**과  
**역정규화된 검색 전용 테이블 기반 검색(v2)**을 비교하여 성능 향상 효과를 분석한 결과를 담고 있다.

## 테스트 환경
- **기존 검색 (v1)**: 여러 테이블(Product, ProductType, Department 등)을 조인하여 검색
- **최적화 검색 (v2)**: 역정규화된 단일 테이블(ProductSearch)을 조회, 멀티 필터링 적용
- 테스트 스크립트: 관리자 상품 생성 → 단일 조회 → 수정 → 삭제 / 사용자 키워드 검색 및 필터 검색 시나리오
- VUs: 200, Duration: 30초

## 결과 요약

| 항목 | 기존 검색 (v1) | 최적화 검색 (v2) |
|------|----------------|------------------|
| 총 요청 수 (http_reqs) | 6,210 (163.11/s) | **11,100 (325.70/s)** |
| 성공률 (checks_succeeded) | 100% | 100% |
| 평균 응답 시간 (http_req_duration) | 908.52ms | **381.82ms** |
| 중앙값 응답 시간 (Median) | 719.81ms | **233.22ms** |
| 95% 응답 시간 (p95) | 2.57s | **1.09s** |
| Iteration 평균 시간 | 11.08s | **5.82s** |
| 데이터 수신량 | 1.1 GB (29 MB/s) | 8.3 MB (245 kB/s)* |

*\* 데이터 수신량 차이는 v1 테스트에 포함된 '전체 상품 조회' API 호출로 인한 차이일 수 있음*

## 성능 향상 포인트
- **처리율(Throughput) 대폭 증가**: 초당 요청 처리량이 약 **2배(100%) 증가** (163/s → 325/s)
- **응답 속도 획기적 개선**: 
  - 평균 응답 시간 **58% 단축** (908ms → 381ms)
  - 중앙값(Median) 응답 시간 **67% 단축** (719ms → 233ms)
  - P95(상위 95% 느린 요청) **57% 단축** (2.57s → 1.09s)
- **사용자 경험 개선**: Iteration(시나리오 1회 수행) 시간이 절반 수준으로 감소 (11s → 5.8s)

## 인덱싱 및 검색 전략 비교

| 구분 | V1 (기존) | V2 (최적화) |
|------|-----------|-------------|
| **검색 방식** | `LIKE %keyword%` (Infix) | `keyword%` (Prefix) 우선 시도 후 `Infix` 보조 |
| **인덱스 활용** | **Full Table Scan** 유발 (중간 일치 검색은 인덱스 사용 불가) | **Index Range Scan** 활용 (전방 일치 시 B-Tree 인덱스 작동) |
| **필터링 효율** | 카테고리 필터링 시 여러 테이블 조인 필요 | `ProductSearch` 테이블의 각 카테고리 컬럼에 **단독 인덱스** 설정 |
| **최적화 기법** | 없음 (DB 기본 조인에 의존) | 검색 빈도가 높은 7개 컬럼에 대해 `@Index` 선언 및 최적화 |

- **V2의 검색 로직**: `searchNamesV2` 메서드는 먼저 인덱스를 탈 수 있는 전방 일치 검색(`StartingWith`)을 수행하고, 결과가 부족할 경우에만 부분 일치 검색을 수행하여 성능과 정확도의 균형을 맞춤.

## 결론
역정규화된 `ProductSearch` 테이블을 도입한 v2 검색 방식은 복잡한 조인 연산을 제거함으로써 **처리율과 응답 속도 모두에서 압도적인 성능 향상**을 보여준다.  
특히 동시 접속자가 많은 상황(200 VUs)에서도 중앙값 200ms대의 쾌적한 응답 속도를 유지하여, 대규모 트래픽 처리에 적합함을 입증하였다.

## 트레이드 오프
- **데이터 중복 저장**: 역정규화로 인해 데이터 저장 공간이 추가로 필요함.
- **데이터 정합성 관리**: 상품 정보(v1) 변경 시 검색 테이블(v2)과의 동기화 로직이 필수적임 (현재 트랜잭션 내 동기화 구현됨).
- **쓰기 성능 영향**: 생성/수정 시 두 테이블을 갱신해야 하므로 쓰기 작업 비용이 소폭 증가할 수 있으나, 읽기 성능 향상분이 이를 상쇄하고도 남음.
