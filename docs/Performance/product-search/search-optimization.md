# 검색 성능 최적화 분석 보고서 (최종)

## 개요
본 문서는 k6 부하 테스트를 통해 **기존 정규화된 DB 구조 기반 검색(v1)**과 **역정규화된 검색 전용 테이블 기반 검색(v2)**을 비교 분석한 최종 결과를 담고 있다. 특히, DB 캐시 효과를 배제하기 위해 **랜덤 키워드 검색** 시나리오를 적용하여 가장 공정한 환경에서 테스트를 수행하였다.

## 테스트 환경
- **테스트 시나리오**: 10종의 다양한 키워드(Trousers, Shirt, Dress 등)를 무작위로 선택하여 검색 수행
- **기존 검색 (v1)**: `Product` 테이블과 10여 개의 카테고리 테이블을 **다중 조인(Join)**하여 검색
- **최적화 검색 (v2)**: 모든 검색 필드를 단일 테이블로 통합한 **역정규화 테이블**(`ProductSearch`) 조회
- **부하 설정**: 가상 사용자(VUs) 100명, 실행 시간 각 20초

---

## 📊 랜덤 키워드 검색 성능 비교 (실제 운영 환경 시뮬레이션)

DB 캐싱 편향을 제거한 후 측정한 핵심 성능 지표이다.

| 측정 항목 | 기존 검색 (v1) | 최적화 검색 (v2) | 성능 향상 (V2 vs V1) |
| :--- | :--- | :--- | :--- |
| **평균 응답 속도 (Avg)** | 101.05ms | **12.64ms** | 🚀 **8배 빠름** |
| **중앙값 (Median)** | 92.00ms | **7.00ms** | 🔥 **13.1배 빠름** |
| **상위 95% 지연 (p95)** | 212.90ms | **41.00ms** | ⚡ **5.2배 더 안정적** |
| **최대 지연 (Max)** | 385.00ms | **253.00ms** | **지연 시간 대폭 감소** |

### 💡 심층 분석
1. **조인(Join)의 물리적 한계 확인**: 
   - 고정 키워드 테스트 대비 V1의 평균 응답 시간이 **58ms에서 101ms로 약 2배 악화**됨. 이는 다양한 검색어 유입 시 DB가 매번 무거운 조인 연산을 수행해야 함을 의미함.
2. **역정규화의 견고함**: 
   - V2는 키워드 변화에 상관없이 **12ms대의 일정한 성능**을 유지함. 단일 테이블 인덱스 스캔의 효율성이 랜덤 쿼리 환경에서 더욱 빛을 발함.
3. **사용자 경험(UX) 격차**: 
   - 중앙값(Median) 기준 **13배의 속도 차이**는 실제 유저가 웹/앱에서 검색 결과를 기다릴 때 체감되는 속도 차이를 명확히 보여줌.

---

## 기술적 성과 요약

| 구분 | V1 (기존) | V2 (최적화) | 비고 |
|------|-----------|-------------|------|
| **검색 쿼리** | 다중 JOIN 발생 | **JOIN 제거 (Zero-Join)** | 구조적 단순화 |
| **인덱스 활용** | 복잡한 관계형 인덱스 | **단일 테이블 전용 인덱스** | 최적화 용이 |
| **부하 대응** | 동시 접속 시 급격한 지연 | **선형적인 응답 속도 유지** | 확장성 확보 |

## 결론
**"역정규화를 통한 조인 제거"**는 이커머스 검색 시스템에서 선택이 아닌 필수적인 최적화 전략이다. 
이번 공정 테스트를 통해 V2 아키텍처가 단순 조회 속도뿐만 아니라, **예측 불가능한 유저의 검색 패턴(랜덤 쿼리)에 대해서도 압도적인 안정성과 성능**을 제공함을 최종적으로 증명하였다.

---

## 기술적 선택과 이유 (Technical Decision)

### 왜 역정규화(Denormalization)인가?
"데이터 중복은 악(Evil)이다"라는 정규화 원칙은 쓰기(Write) 중심 시스템에서는 유효하지만, **읽기(Read)가 90% 이상인 이커머스 검색**에서는 성능의 족쇄가 됩니다.
- **Join 비용 제거**: 사용자가 "청바지"를 검색할 때마다 10개의 테이블을 조인하는 것은 DB CPU를 낭비하는 행위입니다.
- **인덱싱 최적화**: 단일 테이블(`ProductSearch`)에 모든 필드를 모아두면, `Composite Index`를 활용해 복합 필터링 성능을 극대화할 수 있습니다.

## 트레이드 오프와 고민의 흔적 (Trade-off & Constraints)

### 1. 데이터 중복과 스토리지 비용
- **트레이드 오프**: 역정규화로 인해 동일한 데이터가 `Product`와 `ProductSearch` 두 곳에 저장됩니다.
- **판단**: 스토리지 비용(Disk)은 싸고, 컴퓨팅 비용(CPU/Time)은 비쌉니다. 사용자에게 0.1초 더 빠른 검색 결과를 보여주기 위해 디스크를 더 쓰는 것은 **"남는 장사"**라고 판단했습니다.

### 2. 정합성 유지 (Synchronization)
- **고민**: 상품 가격을 수정했는데 검색 결과에는 옛날 가격이 나오면?
- **해결**: 현재는 트랜잭션 내에서 동기화하고 있지만, 향후 MSA 환경에서는 **CDC(Change Data Capture)나 이벤트 기반(Kafka/RabbitMQ)**으로 비동기 동기화하는 것이 확장성 측면에서 더 유리할 것입니다.

## 회고와 배운 점 (Retrospective)

**"검색 성능의 9할은 데이터 구조에서 온다."**
아무리 쿼리를 튜닝하고 캐시를 붙여도, 근본적인 테이블 구조가 복잡하면 한계가 있다는 것을 깨달았습니다.
V1(58ms)에서 V2(12ms)로의 드라마틱한 변화는 단순한 최적화가 아니라 **아키텍처의 패러다임 전환(Read Model 분리)**이 가져온 결과입니다.
이를 통해 **CQRS(Command Query Responsibility Segregation)** 패턴의 필요성과 효과를 실전에서 체감할 수 있었습니다.
